
#' Function for Survival Analysis view.
#' It does survfit and survdiff.
#' @param end_time_fill - "max", "today", or actual value or string expresion of Date.
#' @export
exp_survival <- function(df, time, status, start_time = NULL, end_time = NULL, end_time_fill = "max", time_unit = "day", cohort = NULL, cohort_func = NULL, ...){
  validate_empty_data(df)

  grouped_col <- grouped_by(df)

  orig_levels <- NULL

  if (!is.null(substitute(cohort))) {
    orig_cohort_col <- col_name(substitute(cohort))
    # rename cohort column to workaround the case where the column name has space in it.
    # https://github.com/therneau/survival/issues/41
    colnames(df)[colnames(df) == orig_cohort_col] <- ".cohort" #TODO avoid conflict, and adjust cohort output value from survfit.
    cohort_col <- ".cohort"

    if (!is.null(cohort_func)) {
      df[[cohort_col]] <- extract_from_date(df[[cohort_col]], type=cohort_func)
    }
    quoted_cohort_col <- paste0("`", cohort_col, "`")

    # keep original factor levels to set them back later.
    if (is.factor(df[[cohort_col]])) {
      orig_levels <- levels(df[[cohort_col]])
    }
    else if (is.logical(df[[cohort_col]])) {
      orig_levels <- c("TRUE","FALSE")
    }
  }
  else {
    # no cohort column is set. Just draw a single survival curve.
    cohort_col <- "1"
    quoted_cohort_col <- "1" # no need to quote column name since it is not column.
  }

  # substitute is needed because time can be
  # NSE (non-standard evaluation) column name and it throws an evaluation error
  # without it
  if (is.null(substitute(time))) {
    start_time_col <- col_name(substitute(start_time))
    df[[start_time_col]] <- as.Date(df[[start_time_col]]) # convert to Date in case it is POSIXct.
    if (!is.null(substitute(end_time))) { # if end_time exists, fill NA with today()
      end_time_col <- col_name(substitute(end_time))
      df[[end_time_col]] <- as.Date(df[[end_time_col]]) # convert to Date in case it is POSIXct.
      # set value to fill NAs of end time
      if (is.character(end_time_fill) && end_time_fill == "max") { # type check before comparison is necessary to avoid error.
        end_time_fill_val <- max(df[[start_time_col]], df[[end_time_col]], na.rm = TRUE)
      }
      else if (is.character(end_time_fill) && end_time_fill == "today") {
        end_time_fill_val <- lubridate::today()
      }
      else {
        end_time_fill_val <- as.Date(end_time_fill)
      }
      df[[end_time_col]] <- impute_na(df[[end_time_col]] ,type = "value", val=end_time_fill_val)
    }
    else { # if end_time does not exist, create .end_time column with value of today()
      end_time_col <- avoid_conflict(colnames(df), ".end_time")
      df[[end_time_col]] <- lubridate::today()
    }

    # as.numeric() does not support all units.
    # also support of units are different between Date and POSIXct.
    # let's do it ourselves.
    time_unit_days_str = switch(time_unit,
                                day = "1",
                                week = "7",
                                month = "(365.25/12)",
                                quarter = "(365.25/4)",
                                year = "365.25",
                                "1")
    # we are ceiling survival time to make it integer in the specified time unit.
    # this is to make resulting survival curve to have integer data point in the specified time unit.
    fml <- as.formula(paste0("survival::Surv(ceiling(as.numeric(`", end_time_col, "`-`", start_time_col, "`, units = \"days\")/", time_unit_days_str, "), `", substitute(status), "`) ~ ", quoted_cohort_col))
  }
  else {
    # need to compose formula with non-standard evaluation.
    # simply using time and status in formula here results in a formula that literally looks at
    # "time" columun and "status" column, which is not what we want.
    fml <- as.formula(paste0("survival::Surv(`", substitute(time), "`,`", substitute(status), "`) ~ ", quoted_cohort_col))
  }

  # calls survfit for each group.
  each_func1 <- function(df) {
    ret <- survival::survfit(fml, data = df)
    # strata is ignored by survfit if all rows have same value.
    # In such case, we need to put it back later. Record the value in the model.
    if (cohort_col != "1" && length(unique(df[[cohort_col]])) == 1) {
      ret$single_strata_value = df[[cohort_col]][[1]]
    }
    ret$orig_levels <- orig_levels
    class(ret) <- c("survfit_exploratory", class(ret))
    ret
  }

  # calls survdiff (log rank test) for each group.
  each_func2 <- function(df) {
    ret <- NULL
    if (cohort_col != "1") {
      if (length(unique(df[[cohort_col]])) > 1) {
        tryCatch({
          ret <- survival::survdiff(fml, data = df)
          class(ret) <- c("survdiff_exploratory", class(ret))
        }, error = function(e){
          # error like following is possible. ignore it just for this group, rather than stopping whole thing.
          # Error in solve.default(vv, temp2) : Lapack routine dgesv: system is exactly singular
        })
      }
      else {
        ret <- list(error=simpleError("There is only single cohort in this group."))
        class(ret) <- c("survdiff_exploratory", class(ret))
      }
    }
    ret
  }

  do_on_each_group_2(df, each_func1, each_func2)
}

#' @export
tidy.survfit_exploratory <- function(x, ...) {
  ret <- broom:::tidy.survfit(x, ...)

  # for better viz, add time=0 row for each group when it is not already there.
  add_time_zero_row_each <- function(df) {
    if (nrow(df[df$time==0,]) == 0) { # do this only when time=0 row is not already there.
      df <- rbind(data.frame(time=0, n.risk=df$n.risk[1], n.event=0, n.censor=0, estimate=1, std.error=0, conf.high=1, conf.low=1), df)
    }
    df
  }

  if ("strata" %in% colnames(ret)) {
    nested <- ret %>% dplyr::group_by(strata) %>% tidyr::nest()
    nested <- nested %>% dplyr::mutate(data=purrr::map(data,~add_time_zero_row_each(.)))
    ret <- tidyr::unnest(nested)
    # remove ".cohort=" part from strata values.
    ret <- ret %>% dplyr::mutate(strata = stringr::str_remove(strata,"^\\.cohort\\="))
    # Set original factor level back so that legend order is correct on the chart.
    # In case of logical, c("TRUE","FALSE") is stored in orig_level, so that we can
    # use it here either way.
    if (!is.null(x$orig_levels)) {
      ret <- ret %>%  dplyr::mutate(strata = factor(strata, levels=x$orig_levels))
    }
  }
  else if (!is.null(x$single_strata_value)) { # put back single strata value ignored by survfit.
    ret <- add_time_zero_row_each(ret)
    ret <- ret %>% dplyr::mutate(strata = as.character(x$single_strata_value))
  }
  else {
    ret <- add_time_zero_row_each(ret)
  }

  colnames(ret)[colnames(ret) == "n.risk"] <- "n_risk"
  colnames(ret)[colnames(ret) == "n.event"] <- "n_event"
  colnames(ret)[colnames(ret) == "n.censor"] <- "n_censor"
  colnames(ret)[colnames(ret) == "std.error"] <- "std_error"
  colnames(ret)[colnames(ret) == "conf.low"] <- "conf_low"
  colnames(ret)[colnames(ret) == "conf.high"] <- "conf_high"
  colnames(ret)[colnames(ret) == "strata"] <- "cohort"
  ret
}

# Result from this function is not exposed on UI yet.
#' @export
tidy.survdiff_exploratory <- function(x, ...) {
  if (is.null(x$error)) {
    ret <- broom:::tidy.survdiff(x, ...)
    # TODO: rename .cohort column to original name
  }
  else {
    ret <- data.frame(Note = x$error$message)
  }
  ret
}

#' @export
glance.survdiff_exploratory <- function(x, ...) {
  if (is.null(x$error)) {
    ret <- broom:::glance.survdiff(x, ...)
    colnames(ret)[colnames(ret) == "statistic"] <- "Chi-Square"
    colnames(ret)[colnames(ret) == "df"] <- "Degree of Freedom"
    colnames(ret)[colnames(ret) == "p.value"] <- "P Value"
  }
  else {
    ret <- data.frame(Note = x$error$message)
  }
  ret
}
